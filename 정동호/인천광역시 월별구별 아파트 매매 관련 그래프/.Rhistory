y1 = rnorm(100,4,1)
y2 = rnorm(50,6,2)
windows()
par(mfrow=c(1,2))
hist(y1)
hist(y2)
windows()
par(mfrow=c(1,2))
hist(y1)
hist(y2)
windows()
par(mfrow=c(2,1))
hist(y1)
hist(y2)
summary(y1)
summary(y2)
windows()
par(mfrow=c(2,1))
hist(y1,xlim = c(0,11))
hist(y2,xlim = c(0,11))
abline(v=mean(y1),col=2)
summary(y1)
abline(v=mean(y2),col=2)
windows()
par(mfrow=c(2,1))
hist(y1,xlim = c(0,11))
abline(v=mean(y1),col=2)
hist(y2,xlim = c(0,11))
abline(v=mean(y2),col=2)
windwos()
hist(y1,xlim=c(0,11),col=rgb(1,0,0,0.5),freq = F)
hist(y1,xlim=c(0,11),col=rgb(0,0,0,0.5),freq = F ,add=T)
windows()
hist(y1,xlim=c(0,11),col=rgb(1,0,0,0.5),freq = F)
hist(y1,xlim=c(0,11),col=rgb(0,0,0,0.5),freq = F ,add=T)
windows()
hist(y1,xlim=c(0,11),col=rgb(1,0,0,0.5),freq = F)
hist(y2,xlim=c(0,11),col=rgb(0,0,0,0.5),freq = F ,add=T)
windows()
hist(y1,xlim=c(min(y1)-1,max(y1)+1),col=rgb(1,0,0,0.5),freq = F)
hist(y2,xlim=c(min(y1)-1,max(y1)+1),col=rgb(0,0,0,0.5),freq = F ,add=T)
# density plot
d1 = density(y1)
d2 = density(y2)
windows()
plot(d1,xlim=c(0,11))
lines(d2,xlim=c(0,11),col=2)
windows()
plot(d1,xlim=c(0,11))
lines(d2,xlim=c(0,11),col=2)
windows()
qqplot(y1,y2)
windows()
qqplot(y1,y2)
abline(a=0,b=1,col=2,lty=2)
tmp1 = rnorm(100,4,1)
tmp2 = rnorm(50,6,1)
windows()
qqplot(tmp1,tmp2)
abline(a=0,b=1,col=2,lty=2)
tmp1 = rnorm(100,4,1)
tmp2 = rnorm(50,6,3)
windows()
qqplot(tmp1,tmp2)
abline(a=0,b=1,col=2,lty=2)
windows()
qqplot(tmp1,tmp2)
abline(a=0,b=1,col=2,lty=2)
# 표준편차만 다를 경우 기울기는 다르다는 것을 확인할 수 있다.
graphics.off()
mean1 = mean(y1)
mean2 = mean(y2)
var1 = var(y1)
var2 = var(y2)
sd1 = sd(y1)
sd2=sd(y2)
n1=length(y1)
n2=length(y2)
mean1;mean2
var1;var2
# 정규성 검정
shapiro.test(y1)
shapiro.test(y2)
library(moments)
library(nortest)
lillie.test(y1)
lillie.test(y2)
#######
skewness(y1)
skewness(y2)
agostino.test(y1)
agostino.test(y2)
kurtosis(y1)
kurtosis(y2)
anscombe.test(y1)
anscombe.test(y2)
agostino.test(y1)
agostino.test(y2)
anscombe.test(y1)
anscombe.test(y2)
#######
skewness(y1)
skewness(y2)
agostino.test(y1)
agostino.test(y2)
kurtosis(y1)
kurtosis(y2)
anscombe.test(y1)
anscombe.test(y2)
lillie.test(y1)
lillie.test(y2)
# 틍분산 검정
var.test(y1,y2)
# 두 분산이 같다는 가정 하에 평균 검정(t 검정)
var_pooled = ((n1-1)*var1 + (n2-1)*var2))/(n1+n2-2)
# 두 분산이 같다는 가정 하에 평균 검정(t 검정)
var_pooled = ((n1-1)*var1 + (n2-1)*var2)/(n1+n2-2)
t1 = (mean1-mean2)/sqrt(var_pooled)
p_val = 2*pt(abs(t1),df=n1+n2-2)
p-val
p_val
p_val = 2*(1-pt(abs(t1),df=n1+n2-2))
p_val
t.test(y1,y2,var.equal = T)
t1
# 두 분산이 다르다는 가정 하 평균 검정
t2 = (mean1-mean2)/sqrt((var/n1 + var/n2))
# 두 분산이 다르다는 가정 하 평균 검정
t2 = (mean1-mean2)/sqrt((var1/n1 + var2/n2))
# ~ 자유도
w1 = var1/n1
w2 = var2/n2
df = (w1+w2)^2/(w1^2/(n1-1)+w2^2/(n2-1))
t.test(y1,y2,var.equal = F)
t2
df.sw = (w1+w2)^2/(w1^2/(n1-1)+w2^2/(n2-1))
pval2  = 2*(1-pt(abs(t2),df=df.sw))
pval2
t.test(y1,y2,var.equal = F)
# 교과서 자유도
df.1 = min(n1-1,n2-1)
pval3  = 2*(1-pt(abs(t2),df=df.1))
pval3
# 두모집단이 정규분포가 아니더라도 표본이 충분하다면
# 중심극한정리를 이용하여 검정을 수행할 수 있다.
pval4 = 2*(1-pnorm(abs(t2)))
pval4
# 비모수 검정
# 각 모집단이 정규분포를 따른다고 보기 힘들고 표본의 크기가 충분치 않을 경우
# 비모수 검정을 수행할 수 있다.
wilcox.test(y1,y2)
# 두분포가 다른디 검정
ks.test(y1,y2)
tmp1 = rnorm(100,4,1)
tmp2 = rnorm(50,6,1)
ks.test(tmp1,tmp2)
tmp1 = rnorm(100,6,1)
tmp2 = rnorm(50,6,4)
ks.test(tmp1,tmp2)
data(iris)
head(iris)
species = iris$Species
swidth = iris$Sepal.Width
# summary
summary(swidth)
windows()
hist(swidth)
library(installr)
updateR()
version
rm(list=ls())
# 결정트리 학습법
install.packages("tree")
library(tree)
rm(list=ls())
data("mtcars")
View(mtcars)
# 중회귀분석 연습
# 배기량(disp), 마력(hp), 무게(wt)가 연비(mpg)에 미치는 영향에 대하여 분석
input = mtcars[,c("mpg","disp","hp","wt")]
x11()
pairs(input)
x11()
plot(input$disp,input$mpg)
lines(lowess(input$mpg~input$disp),col=2)
lines(lowess(input$mpg~input$disp,f=0.2),col=2)# lowess 공부
abline(lm(input$mpg~input$disp),col=3)
# disp가 증가할수록 mpg가 감소하는 경향을 보인다.
# But 직선의 형태로 감소하기보다는 곡선의 형태로 감소하는 경향이 있다.
# 즉, 비선형의 모양이다.
graphics.off()
x11()
plot(input$hp,input$mpg)
lines(lowess(input$mpg~input$hp,f=0.2),col=2)# lowess 공부
abline(lm(input$mpg~input$hp),col=3)
# disp가 증가할수록 mpg가 감소하는 경향을 보인다.
# But 직선의 형태로 감소하기보다는 곡선의 형태로 감소하는 경향이 있다.
# 즉, 비선형의 모양이다.
graphics.off()
x11()
plot(input$hp,input$mpg)
lines(lowess(input$mpg~input$hp),col=2)# lowess 공부
abline(lm(input$mpg~input$hp),col=3)
x11()
plot(input$wt,input$mpg)
lines(lowess(input$mpg~input$wt),col=2)# lowess 공부
abline(lm(input$mpg~input$wt),col=3)
# 비선형에 대한 파생변수 생성
input$disp2=input$disp*input$disp
input$hp2=input$hp*input$hp
input$wt2=input$wt*input$wt
cor(input)
cor.test(input$mpg,input$disp)
cor(input[,1:4])
# 중회귀분석
model1 = lm(mpg~disp+hp+wt,data=input)
model1
summary(model1)
aov(model1)
model2 = lm(mpg~hp+wt,data=input)
summary(model2)
# 잔차검증
pred = predict(model2)
resid = residuals(model2)
x11()
plot(pred,resid)
abline(h=0,col=3)
lines(lowess(resid~pred),col=2)
x11()
plot(input$disp,resid)
abline(h=0,col=3)
lines(lowess(resid~input$disp),col=2)
x11()
plot(input$hp,resid)
abline(h=0,col=3)
lines(lowess(resid~input$hp),col=2)
x11()
plot(input$wt,resid)
abline(h=0,col=3)
lines(lowess(resid~input$wt),col=2)
graphics.off()
model3 = lm(mpg~disp+disp2+hp+hp2+wt+wt2,data=input)
summary(model3)
model4 = lm(mpg~disp2+hp+hp2+wt+wt2,data=input)
summary(model4)
model5 = lm(mpg~hp+hp2+wt+wt2,data=input)
summary(model5)
# 최종모형에 대한 잔차 검증
pred = predict(model5)
resid = residuals(model5)
x11()
plot(pred,resid)
abline(h=0,col=3)
lines(lowess(resid~pred),col=2)
x11()
plot(input$disp,resid)
abline(h=0,col=3)
lines(lowess(resid~input$disp),col=2)
x11()
plot(input$hp,resid)
abline(h=0,col=3)
lines(lowess(resid~input$hp),col=2)
x11()
plot(input$wt,resid)
abline(h=0,col=3)
lines(lowess(resid~input$wt),col=2)
x11()
hist(resid)
library(moments)
skewness(resid)
agostino.test(resid)
kurtosis(resid)
anscombe.test(resid)
shapiro.test(resid)
x11()
qqnorm(resid)
qqline(resid,col=2)
shapiro.test(resid)
summary(mpg)
summary(input$mpg)
input$mpg = log(input$mpg)
x11()
plot(input$disp,input$mpg)
lines(lowess(input$mpg~input$disp,f=0.2),col=2)# lowess 공부
abline(lm(input$mpg~input$disp),col=3)
x11()
plot(input$hp,input$mpg)
lines(lowess(input$mpg~input$hp),col=2)# lowess 공부
abline(lm(input$mpg~input$hp),col=3)
input$mpg = log(input$mpg)
input$lmpg = log(input$mpg)
x11()
plot(input$hp,input$lmpg)
lines(lowess(input$lmpg~input$hp),col=2)# lowess 공부
abline(lm(input$lmpg~input$hp),col=3)
x11()
plot(input$wt,input$lmpg)
lines(lowess(input$lmpg~input$wt),col=2)# lowess 공부
abline(lm(input$lmpg~input$wt),col=3)
cor(input[,c("lmpg","disp","hp","wt")])
# log(연비) vs disp, hp, hp2, wt
model6 = lm(lmpg~disp+hp+hp2+wt,data=input)
summary(model6)
model7 = lm(lmpg~hp+hp2+wt,data=input)
summary(model7)
rm(list=ls())
## 통분반
data("mtcars")
# 중회귀분석 연습
# 배기량(disp), 마력(hp), 무게(wt)가 연비(mpg)에 미치는 영향에 대하여 분석
input = mtcars[,c("mpg","disp","hp","wt")]
# 비선형에 대한 파생변수 생성
input$disp2=input$disp*input$disp
input$hp2=input$hp*input$hp
input$wt2=input$wt*input$wt
input$lmpg = log(input$mpg)
model6 = lm(lmpg~disp+hp+hp2+wt,data=input)
summary(model6)
# disp 제거
model7 = lm(lmpg~hp+hp2+wt,data=input)
summary(model7)
# hp2 제거
model8 = lm(lmpg~hp+wt,data=input)
summary(model8)
# 최종모형에 대한 잔차 검증
pred = predict(model8)
resid = residuals(model8)
x11()
plot(pred,resid)
abline(h=0,col=3)
lines(lowess(resid~pred),col=2)
x11()
qqnorm(resid)
qqline(resid,col=2)
shapiro.test(resid)
rm(list=ls())
pbinom(1,size=2,prob=0.5)
dbinom(1,2,0.5)
# X ~ B(2,0.5), p(X = 1)
qbinom(0.75,2,0.5)
rbinom(100,2,0.5)
# X~B(2,0.5), P(X=1)
set.seed(1234)
rbinom(100,2,0.5)
# X~B(2,0.5), P(X=1)
set.seed(1234)
table(rbinom(100,2,0.5))
table(rbinom(1000,2,0.5))
table(rbinom(10000,2,0.5))
ns <- 100000
x <- rpois(n = ns, lambda = 3)
c(mean(x), var(x))
x11()
hist(x)
ppois(1,3,lower.tail = F)
ppois(0,3,lower.tail = F)
dpois(0,3)
# 예제7
# p = 0.04, n=200, 10명 이하 색맹일 확률
pbinom(10,200,0.04)
# X~b(200,0.04) -> P(X<=10)
pbinom(10,200,0.04)
# 이때 poisson으로 보면,
200*0.04
ppois(10,8)
# X~b(200,0.04) -> P(X<=10)
pbinom(10000,200000,0.04)
# X~b(200,0.04) -> P(X<=10)
pbinom(10000,200000,0.05)
# 이때 poisson으로 보면,
200000*0.05
ppois(10000,10000)
sum(dpois(x = c(2,3), lambda = 1.2))
# P(X=2)+P(X=3)
ppois(3,1.2)-ppois(1,1.2)
# 정규분포
x1<-rnorm(1000,0,1)
x2<-rnorm(1000,5,1)
x = x1
pnorm(mean(x)+sd(x),mean = mean(x),sd = sd(x))-pnorm(mean(x)-sd(x),mean = mean(x),sd = sd(x))
pnorm(mean(x)+2*sd(x),mean = mean(x),sd = sd(x))-pnorm(mean(x)-2*sd(x),mean = mean(x),sd = sd(x))
pnorm(mean(x)+3*sd(x),mean = mean(x),sd = sd(x))-pnorm(mean(x)-3*sd(x),mean = mean(x),sd = sd(x))
x11()
curve(sin,from = 0,to=2*pi)
x11()
curve(pnorm(x,0,1),from=min(sort(x1)),to=max(sort(x1)))
x11()
curve(dnorm(x,0,1),from=min(sort(x1)),to=max(sort(x1)),xlim = c(-3,10))
curve(dnorm(x,5,1),from=min(sort(x2)),to=max(sort(x2)),xlim = c(-3,10),add=T,col="red")
x3 = c(x1,x2)
x11()
boxplot(x3)
x3 = c(x1,x2)
x11()
boxplot(x3)
x11()
hist(x3)
x11()
par(mfrow=c(1,2))
boxplot(x3)
hist(x3)
# example 1
# axes : 테두리 관련 함수
dev.off()
x11()
curve(expr = dnorm(x),
from = -3.5,
to = +3.5,
xlab = 'x',
ylab = 'f(x)',
axes = FALSE)
abline(h = 0)
a = -4; b = 4;
x2 <- c(a, seq(a,b,0.01), b)
y2 <- c(0,dnorm(seq(a,b,0.01)),0)
x11()
polygon(x2,y2,col='skyblue')
a = -4; b = 4;
x2 <- c(a, seq(a,b,0.01), b)
y2 <- c(0,dnorm(seq(a,b,0.01)),0)
polygon(x2,y2,col='skyblue')
abline(v = 0, lty = 2)
x11()
curve(expr = dnorm(x),
from = -3.5,
to = +3.5,
xlab = 'x',
ylab = 'f(x)',
axes = FALSE)
abline(h = 0)
# # 그래프의 어느 쪽에 축을 그릴지 지정하는 정수
# 1 = 아래쪽 (below side)
# 2 = 왼쪽 (left side)
# 3 = 위쪽 (above side)
# 4 = 오른쪽 (right side)
Axis(side=1, labels=FALSE)
Axis(side=2, labels=FALSE)
a = -4; b = 4;
x2 <- c(a, seq(a,b,0.01), b)
y2 <- c(0,dnorm(seq(a,b,0.01)),0)
polygon(x2,y2,col='skyblue')
abline(v = 0, lty = 2)
axis(side = 1, at = 0,
labels = c(expression(mu)))
# x2<-2, x2>2 값을 제외하고 x22에 저장
x22 = x2[x2<-2 & x2>2]
x11()
qqnorm(x22)
rm(list=ls())
rm(list=ls())
### 강남구 제곱미터당 평균 매매가 시계열 분석 ###
setwd('C:/Users/wndy4/Desktop/Project_apartment/이건도')
dat = read.csv('서울집값.csv',header=T,stringsAsFactors=F)
?read.csv
dat = read.csv('서울집값.csv',header=T,stringsAsFactors=F)
### 강남구 제곱미터당 평균 매매가 시계열 분석 ###
setwd('C:/Users/wndy4/Desktop/Project_apartment/이건도')
dat = read.csv('서울집값.csv',header=T,stringsAsFactors=F)
dat = read.csv('강남구 집값.csv',header=T,stringsAsFactors=F)
View(dat)
str(dat)
colnames(dat) = gsub('X','',colnames(dat))
colnames(dat)
gu_name = dat$지역
gu_name = dat$지역
gu_name
gu_dat = t(dat[,2:37])
ts_gu_mat = ts(data = gu_dat,start = c(2016,1),frequency = 12)
x11()
plot(ts_gu_mat[,1])
# 강남구 동이름
d_name = dat$지역
gu_name
# 강남구 동이름
d_name = dat$지역
d_name
View(ts_gu_mat)
x11()
plot(ts_gu_mat[,1],xlab="201601 ~ 201812",ylab="제곱미터당 평균 매매가",main ="강남구 아파트 제곱미터당 평균 매매가")
###  인천광역시 전체 아파트 가격과 상관관계 분석
## set working directory
setwd('C:/Users/wndy4/Desktop/Project_DEMA/정동호/인천광역시 월별구별 아파트 매매 관련 그래프')
###  인천광역시 전체 아파트 가격과 상관관계 분석
## set working directory
setwd('C:/Users/wndy4/Desktop/Project_apartment/정동호/인천광역시 월별구별 아파트 매매 관련 그래프')
## Load csv file
dat1 = read.csv('인천지역 아파트 매매가격 변동(월단위).csv',header=T,stringsAsFactors=F)
## 열명 수정
colnames(dat1) = gsub('X','',colnames(dat1))
## 구군별 합계 시계열 데이터 매트릭스
# data에 transpose 하는 이유는 plot 에서 행 벡터 인식 X 열 벡터 인식 O
incheon = t(dat1[1,3:41])
## 구군별 합계 시계열 데이터 매트릭스
# data에 transpose 하는 이유는 plot 에서 행 벡터 인식 X 열 벡터 인식 O
incheon1 = t(dat1[1,3:38])
ts_incheon1 = ts(data = incheon1,start = c(2016,1),frequency = 12)
x11()
plot(ts_gu_mat[,1],xlab="201601 ~ 201812",ylab="제곱미터당 평균 매매가",
main ="강남구 아파트 제곱미터당 평균 매매가",ylim=c(min(ts_incheon1),max(ts_gu_mat[,1])))
lines(ts_incheon1,col=2)
x11()
plot(ts_incheon1,ts_gu_mat[,1])
x11()
plot(incheon1,gu_dat[,1])
x11()
plot(gu_dat[,1],incheon1,xlab="강남아파트 제곱미터당 평균 매매가",ylab="인천아파트 제곱미터당 평균 매매가",
main="강남아파트 평균 매매가 vs 인천아파트 평균 매매가")
cor(gu_dat[,1],incheon1)
cor.test(x = gu_dat[,1], y = incheon1, method="spearman")
x11()
plot(gu_dat[,1],incheon1,xlab="강남아파트 제곱미터당 평균 매매가",ylab="인천아파트 제곱미터당 평균 매매가",
main="강남아파트 평균 매매가 vs 인천아파트 평균 매매가")
