#### 결정트리 학습법1
# tree package 이용
library(tree)
library(caret)
library(rpart)
library(party)
graphics.off()
# load train.csv file
setwd("C:/Users/wndy4/Desktop/Project_DEMA")

train = read.csv('train set.csv',header = T, stringsAsFactors = F)


View(train)

# 불필요한 항목 제거
train = train[,-c(1,2,3)]

# tree 학습
# control.tree1 = tree.control(nrow(train),mincut=5)
tree1 = tree(train$평균매매가.제곱미터당.만원.~.,data=train)
tree1

# tree plot
x11()
plot(tree1)
text(tree1,label = "yval")
?text

# pruning
?cv.tree
cv.tree1 = cv.tree(tree1,FUN = prune.tree)
x11()
plot(cv.tree1)
# cv그래프 상 size 8에서 가장 분산이 낮으므로 pruning 불필요

# 검증 작업
# validation
valid = read.csv('validation set.csv',header = T,stringsAsFactors = F)
valid = valid[,-c(1,2,3)]

# valid을 이용한 적합값 생성
predict1.valid = predict(tree1,valid,type='vector')

# valid 이용한 MSE 구하기 & plot y vs y_hat
y = valid$평균매매가.제곱미터당.만원.
y_hat = predict1.valid
mean((y - y_hat)^2)

x11()
plot(y,y_hat)
abline(0,1,col=2)


#### 결정트리 학습법2
# rpart package 사용
?rpart
?rpart.control
control = rpart.control(xval = 10,cp=0, minsplit = 150)
# xval : 교차 타당성의 fold 개수
# cp : complexity parameter, 오분류값, cp=0이면 오분류값 최소, 디폴트는 0.01
# minsplit : 한 노드를 분할하기 위해 필요한 데이터의 개수
tree2 = rpart(train$평균매매가.제곱미터당.만원.~.,data=train,method = 'anova',control = control)
tree2
summary(tree2)
x11()
plot(tree2)
text(tree2)

# rattle 패키지를 이용한 트리 그림 구현
x11()
fancyRpartPlot(tree2)
# pruning
printcp(tree2) # xerror(오분율)
?printcp

x11()
plotcp(tree2) # minsplit이 많든, 적든 size가 클수록 xerorr(오분율)은 계속 낮아지는 것을 확인

# validation 이것도 어떻게 해야하나????
predict2 = predict(tree2,newdata = valid)

y = valid$평균매매가.제곱미터당.만원.
y_hat = predict2
e = y - y_hat
cor.test(y,y_hat)

x11()
hist(e)

shapiro.test(e)

x11()
qqnorm(e)

graphics.off()

#### 결정트리 학습법3
# ctree 이용
# 좀더 알아보자
install.packages('party')
library(party)
?ctree_control
control3 = ctree_control(minsplit = 300)
tree3 = ctree(train$평균매매가.제곱미터당.만원.~.,data=train,control = control3)

x11()
plot(tree3)